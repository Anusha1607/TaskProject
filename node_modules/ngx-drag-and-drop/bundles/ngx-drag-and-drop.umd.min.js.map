{
  "version": 3,
  "file": "ngx-drag-and-drop.umd.min.js",
  "sources": [
    "ng://ngx-drag-and-drop/out/src/app/ngx-drag-and-drop/ngx-drag-and-drop.utils.ts",
    "ng://ngx-drag-and-drop/out/src/app/ngx-drag-and-drop/ngx-drag-and-drop.directive.ts",
    "ng://ngx-drag-and-drop/out/src/app/ngx-drag-and-drop/ngx-drag-and-drop.module.ts"
  ],
  "sourcesContent": [
    "/* Polyfill */\nexport interface MyDocument extends Document {\n    elementsFromPoint(x:number, y:number) : Array<Element>;\n  }\n  export let myDoc = <MyDocument>document;\n  \n  //(<MyDocument>document).elementsFromPoint = (<MyDocument>document).elementsFromPoint ||\n  myDoc.elementsFromPoint = myDoc.elementsFromPoint || function(x:number, y:number) : Array<Element> {\n    let element, elements = [];\n    let old_visibility = [];\n    while (true) {\n        element = document.elementFromPoint(x, y);\n        if (!element || element === document.documentElement) {\n            break;\n        }\n        elements.push(element);\n        old_visibility.push(element.style.visibility);\n        element.style.visibility = 'hidden'; // Temporarily hide the element (without changing the layout)\n    }\n    for (let k = 0; k < elements.length; k++) {\n        elements[k].style.visibility = old_visibility[k];\n    }\n    return elements;\n  };\n  ",
    "import { Directive, ElementRef, Input, HostListener, EventEmitter, Output, OnInit, OnDestroy } from '@angular/core';\nimport { myDoc } from './ngx-drag-and-drop.utils';\n\n/* Polyfill TouchEvent */\nexport interface MyTouchEvent extends TouchEvent {}\n/*\ninterface ShadowRoot extends DocumentFragment {\n    styleSheets     : StyleSheetList;\n    innerHTML       : string;\n    host            : Element;\n    activeElement   : Element;\n    elementFromPoint        (x : number, y : number) : Element;\n    elementsFromPoint       (x : number, y : number) : Element[];\n    caretPositionFromPoint  (x : number, y : number); // => CaretPosition\n};\n\ninterface ElementWithShadowRoot extends HTMLElement {\n    shadowRoot  : ShadowRoot;\n};*/\nconst dragPointerId = 'dragPointer';\ntype Pointer = {x: number, y: number};\nclass DragManager {\n    draggingPointer     = new Map<string, Pointer>();\n    draggedStructures   = new Map<string, Draggable | DragEvent>();\n    dropZones           = new Map<Element, Dropzone >();\n    //constructor() {}\n    preStartDrag( idPointer: string, dragged: Draggable, x: number, y: number\n                , delay: number, dist: number) : Promise<any> {\n        // console.log('preStartDrag', idPointer, dragged, x, y, delay);\n        this.draggingPointer  .set(idPointer, {x: x, y: y});\n        return new Promise<void>( (resolve, reject) => {\n            setTimeout(() => {\n                let ptr   = this.draggingPointer.get(idPointer);\n                let gogo  = ptr && (Math.abs(x - ptr.x) + Math.abs(y - ptr.y)) < dist;\n                this.draggingPointer.delete(idPointer);\n                if(gogo) {resolve();} else {reject();}\n            }, Math.max(0, delay));\n        }); // End of Promise\n    }\n    public startDrag(idPointer: string, dragged: Draggable | DragEvent, x: number, y: number) : Map<Element, Dropzone> {\n        // console.log('startdrag', dragged, x, y);\n        this.draggedStructures.set(idPointer, dragged);\n        let possibleDropZones = new Map<Element, Dropzone>();\n        this.dropZones.forEach( dz => {\n            if( dz.checkAccept(dragged) ) {\n                dz.appendDropCandidatePointer( idPointer );\n                possibleDropZones.set(dz.root, dz);\n            }\n        } );\n        return possibleDropZones;\n    }\n    public isAssociatedToDropZone(element: Element) : boolean {\n        return this.dropZones.has( element );\n    }\n    public registerDropZone( dropzone: Dropzone ) {\n        this.dropZones.set(dropzone.root, dropzone);\n    }\n    public unregisterDropZone( dropzone: Dropzone ) {\n        this.dropZones.delete(dropzone.root);\n    }\n    public pointerMove(idPointer: string, x: number, y: number) : boolean {\n        let ptr = this.draggingPointer.get(idPointer);\n        if(ptr) {ptr.x = x; ptr.y = y;}\n        let dragged = this.draggedStructures.get(idPointer);\n        if(dragged && dragged instanceof Draggable) {\n            dragged.move(x, y);\n        }\n        return dragged !== undefined;\n    }\n    public pointerRelease(idPointer: string) : boolean {\n        let dragged = this.draggedStructures.get(idPointer);\n        if(dragged) {\n            if(dragged instanceof Draggable) {\n                dragged.stop();\n            }\n        }\n        this.draggedStructures.delete(idPointer);\n        this.draggingPointer  .delete(idPointer);\n        return dragged !== undefined;\n    }\n}\nlet DM = new DragManager();\n\nlet dragDropInit = false;\n\n\n@Directive({\n    selector: '*[drag-and-drop-wrapper]'\n})\nexport class DragDrop {\n    nbDragEnter = 0;\n    constructor() {\n        if(dragDropInit) {\n            console.error( 'Do not create multiple instance of directive drag-and-drop-wrapper !' );\n        } else {\n            dragDropInit = true;\n        }\n    }\n    removeFeedbackForDragPointer() {\n        this.nbDragEnter = 0;\n        DM.dropZones.forEach( dz => {\n            dz.removePointerHover           (dragPointerId);\n            dz.removeDropCandidatePointer   (dragPointerId);\n        });\n    }\n    @HostListener( 'document: drop', ['$event'] ) drop( e ) {\n        // console.log( 'document drop', e );\n        e.preventDefault();\n        e.stopPropagation();\n        this.removeFeedbackForDragPointer();\n    }\n    @HostListener( 'document: dragover', ['$event'] ) dragover( e ) {\n        // console.log( 'document dragover', e );\n        e.preventDefault();\n        e.stopPropagation();\n    }\n    @HostListener( 'document: dragenter', ['$event'] ) dragenter( e ) {\n        this.nbDragEnter++;\n        if(this.nbDragEnter === 1) {\n            DM.startDrag(dragPointerId, e, -1, -1);\n        }\n    }\n    @HostListener( 'document: dragleave', ['$event'] ) dragleave( e ) {\n        this.nbDragEnter--;\n        if(this.nbDragEnter === 0) {\n            this.removeFeedbackForDragPointer();\n            DM.pointerRelease( dragPointerId );\n        }\n    }\n    @HostListener( 'document: dragend', ['$event'] ) dragend( e ) {\n        DM.pointerRelease( dragPointerId );\n        this.removeFeedbackForDragPointer();\n        e.preventDefault();\n    }\n    @HostListener( 'document: mousemove', ['$event'] ) mousemove( e ) {\n        DM.pointerMove   ('mouse', e.clientX, e.clientY);\n    }\n    @HostListener( 'document: mouseup'  , ['$event'] ) mouseup  ( e ) {\n        DM.pointerRelease('mouse');\n    }\n    @HostListener( 'document: touchmove', ['$event'] ) touchmove( e ) {\n        for (let i = 0; i < e.changedTouches.length; i++) {\n            let touch:Touch = e.changedTouches.item(i);\n            if (DM.pointerMove(touch.identifier.toString(), touch.clientX, touch.clientY)) {\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        }\n    }\n    @HostListener( 'document: touchend' , ['$event'] ) touchend ( e ) {\n        for(let i=0; i<e.changedTouches.length; i++) {\n            let touch : Touch = e.changedTouches.item(i);\n            if( DM.pointerRelease(touch.identifier.toString()) ) {\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        }\n    }\n}\n\nlet offsetElement = (element: HTMLElement) : {left: number, top: number} => {\n    let left = 0, top = 0;\n    while (element) {\n        top  += element.offsetTop  - element.scrollTop  + element.clientTop;\n        left += element.offsetLeft - element.scrollLeft + element.clientLeft;\n        element = element.offsetParent as HTMLElement;\n    }\n    return {left: left, top: top}; // + element.scrollTop; //window.scrollY;\n};\n\n@Directive({\n    selector: '*[draggable]'\n})\nexport class Draggable implements OnInit, OnDestroy {\n    @Input ('draggable' ) draggedData : any;\n    @Input ('drag-start-delay') startDelay : number;\n    @Input ('start-distance') startDistance: number;\n    @Input ('disabled') disabled: boolean = false;\n    @Output('drag-start') onDragStart = new EventEmitter<any>();\n    @Output('drag-end'  ) onDragEnd   = new EventEmitter<any>();\n    private isBeingDragged                : boolean = false;\n    private cloneNode                     : HTMLElement = null;\n    private currentDropZone               : Dropzone;\n    private possibleDropZones = new Map<Element, Dropzone>();\n    private dx : number;\n    private dy : number;\n    private ox : number;\n    private oy : number;\n    private tx : number;\n    private ty : number;\n    private idPointer : string;\n    private root : HTMLElement;\n    constructor(el: ElementRef) {\n        this.root = el.nativeElement;\n        if(!dragDropInit) {\n           console.error('You should add one dragdrop attribute to your code before using draggable');\n        }\n        //console.log( 'new instance of Draggable', this );\n    }\n    ngOnInit() {\n        //\n    }\n    ngOnDestroy() {\n        // XXX No stop in case of unplug while dragging... : // this.stop();\n    }\n    @HostListener('mousedown' , ['$event']) onMouseDown (event : MouseEvent) {\n        //console.log('mousedown on', this, event);\n        console.log(this.disabled)\n        if (!this.disabled) {\n            event.preventDefault();\n            event.stopPropagation();\n            this.prestart('mouse', event.clientX, event.clientY);\n        }\n    }\n    @HostListener('touchstart', ['$event']) onTouchStart(event: MyTouchEvent) {\n        //console.log('touchstart on', this);\n        // event.preventDefault();\n        event.stopPropagation();\n        for(let i=0; i<event.changedTouches.length; i++) {\n            let touch : Touch = event.changedTouches.item(i);\n            this.prestart(touch.identifier.toString(), touch.clientX, touch.clientY);\n        }\n    }\n    prestart(idPointer: string, x: number, y: number) {\n        DM.preStartDrag(idPointer, this, x, y, this.startDelay || 0, this.startDistance || 10).then(\n            () => {\n                this.start(idPointer, x, y);\n            },\n            () => {\n                // console.error('skip the drag');\n            }\n            );\n    }\n    start(idPointer: string, x: number, y: number) {\n        if( !this.isBeingDragged ) {\n            this.isBeingDragged = true;\n            this.idPointer = idPointer;\n            // let bbox = this.root.getBoundingClientRect();\n            let offset = offsetElement(this.root);\n            this.ox = x; this.oy = y;\n            this.dx = x - offset.left; // Math.round(bbox.left + window.pageXOffset);\n            this.dy = y - offset.top ; // Math.round(bbox.top  + window.pageYOffset);\n            /*let D = document.querySelector('#debug');\n            D.innerHTML = window.pageXOffset + ' ; ' + window.pageYOffset + '<br/>'\n                        + window.scrollX + ' ; ' + window.scrollY + '<br/>'\n                        + this.root.offsetLeft + ' ; ' + this.root.offsetTop + '<br/>'\n                        // + bbox.left + ' ; ' + bbox.top\n                        ;*/\n            this.tx = this.root.offsetWidth ; // bbox.width ;\n            this.ty = this.root.offsetHeight; // bbox.height;\n\n            this.getClone();\n            this.cloneNode.style.left = (x - this.dx /* + window.pageXOffset */) + 'px';\n            this.cloneNode.style.top  = (y - this.dy /* + window.pageYOffset */) + 'px';\n            this.onDragStart.emit( this.draggedData );\n            this.possibleDropZones = DM.startDrag(idPointer, this, x, y);\n        }\n    }\n    stop() {\n        this.possibleDropZones.forEach( dz => {\n            dz.removePointerHover           (this.idPointer);\n            dz.removeDropCandidatePointer   (this.idPointer);\n        } );\n        this.isBeingDragged = false;\n        this.possibleDropZones.clear();\n        this.idPointer = null;\n        if(this.currentDropZone) {\n            this.currentDropZone.drop( this.draggedData );\n        }\n        this.currentDropZone = null;\n        this.onDragEnd.emit( this.draggedData );\n        this.deleteClone();\n    }\n    move(x: number, y: number) : this {\n        let element : Element = null;\n        if(this.cloneNode === null) {\n            this.getClone();\n        }\n        if(this.cloneNode) {\n            this.cloneNode.style.left = (x - this.dx /* + window.pageXOffset */) + 'px';\n            this.cloneNode.style.top  = (y - this.dy /* + window.pageYOffset */) + 'px';\n            // let parent = this.cloneNode.parentElement;\n            let visibility = this.cloneNode.style.visibility;\n            // parent.removeChild( this.cloneNode );\n            this.cloneNode.style.visibility = 'hidden';\n            let top = this.cloneNode.style.top;\n            this.cloneNode.style.top = '999999999px';\n\n            // let L = <Array<Element>>myDoc.elementsFromPoint(x-window.pageXOffset, y-window.pageYOffset);\n            element = myDoc.elementFromPoint(x, y);\n\n            this.cloneNode.style.top = top;\n            this.cloneNode.style.visibility = visibility;\n            // parent.appendChild( this.cloneNode );\n\n            let prevDropZone = this.currentDropZone;\n            while(element) {\n                // Check if we are on top of a dropZone\n                this.currentDropZone = this.possibleDropZones.get( element );\n                if(this.currentDropZone) {break;}\n                element = <Element>element.parentElement;\n            }\n            if(prevDropZone !== this.currentDropZone) {\n                if(prevDropZone) {\n                    prevDropZone.removePointerHover( this.idPointer );\n                }\n                if(this.currentDropZone) {\n                    this.currentDropZone.appendPointerHover( this.idPointer );\n                }\n            }\n            /*this.possibleDropZones.forEach( dz => dz.removePointerHover(this.idPointer) );\n            while(element) {\n                // Check if we are on top of a dropZone\n                this.currentDropZone = this.possibleDropZones.get( element );\n                if(this.currentDropZone) {\n                    this.currentDropZone.appendPointerHover( this.idPointer );\n                    break;\n                }\n                element = <Element>element.parentElement;\n            }*/\n        }\n        return this;\n    }\n    deepStyle(original: Element, clone: Element) {\n        if(original instanceof HTMLElement) {\n            let style = window.getComputedStyle(original);\n            for (let i = 0; i < style.length; i++) {\n                let att = style[i];\n                (clone as HTMLElement).style[att] = style[att];\n            }\n            for(let i=0; i<original.children.length; i++) {\n                this.deepStyle(original.children.item(i), (clone as HTMLElement).children.item(i));\n            }\n        }\n    }\n    deleteClone() {\n        if(this.cloneNode) {\n            if(this.cloneNode.parentNode) {\n                this.cloneNode.parentNode.removeChild(this.cloneNode);\n            }\n            this.cloneNode = null;\n        }\n    }\n    getClone() : HTMLElement {\n        if(this.cloneNode === null) {\n            this.cloneNode = <HTMLElement>this.root.cloneNode(true);\n            // Apply computed style :\n            this.deepStyle( this.root, this.cloneNode);\n\n            // Insert the clone on the DOM\n            document.body.appendChild( this.cloneNode );\n            this.cloneNode.style.position        = 'absolute';\n            this.cloneNode.style.zIndex          = '999';\n            this.cloneNode.style.marginLeft      = '0';\n            this.cloneNode.style.marginTop       = '0';\n            this.cloneNode.style.marginRight     = '0';\n            this.cloneNode.style.marginBottom    = '0';\n            this.cloneNode.style.opacity         = '';\n            this.cloneNode.style.cursor          = '';\n            this.cloneNode.style.transform       = '';\n            this.cloneNode.style.transformOrigin = '';\n            this.cloneNode.style.animation       = '';\n            this.cloneNode.style.transition      = '';\n            this.cloneNode.classList.add( 'drag-and-drop-clone-node' );\n            // console.log( this.cloneNode.style );\n        }\n        return this.cloneNode;\n    }\n}\n\n@Directive({ selector: '*[dropzone]' })\nexport class Dropzone implements OnInit, OnDestroy {\n    nbDragEnter = 0;\n    public root : HTMLElement;\n    @Input('drag-css'     ) dragCSS     : string;\n    @Input('drag-over-css') dragOverCSS : string;\n    @Input('drag-over-css-for-draggable') dragOverCSS_pointer : string;\n    @Input('accept-function') acceptFunction : (data: any) => boolean;\n    @Output('ondrop')     onDropEmitter = new EventEmitter<any>();\n    @Output('drag-start') onDragStart   = new EventEmitter<any>();\n    @Output('drag-end')   onDragEnd     = new EventEmitter<any>();\n    @Output('drag-enter') onDragEnter   = new EventEmitter<any>();\n    @Output('drag-leave') onDragLeave   = new EventEmitter<any>();\n\n    // CSS when canDrop and startdraggable\n    private dropCandidateofPointers : Array<string> = [];\n    private pointersHover           : Array<string> = [];\n    constructor(el: ElementRef) {\n        if(!dragDropInit) {\n            console.error('You should add one dragdrop attribute to your code before using dropzone');\n        }\n        this.root = el.nativeElement;\n        // this.acceptFct = YES;\n        DM.registerDropZone(this);\n    }\n    ngOnInit() {\n        //\n    }\n    ngOnDestroy() {\n        // console.log( 'TODO: Should implement dropzone destoy');\n        DM.unregisterDropZone( this );\n    }\n    @HostListener('dragenter' , ['$event']) BrowserDragEnter (event : MouseEvent) {\n        // console.log( 'BrowserDragEnter', this, event );\n        this.nbDragEnter++;\n        if(this.nbDragEnter === 1) {\n            this.appendPointerHover(dragPointerId);\n        }\n    }\n    @HostListener('dragleave' , ['$event']) BrowserDragLeave (event : MouseEvent) {\n        // console.log( 'BrowserDragEnter', this, event );\n        this.nbDragEnter--;\n        if(this.nbDragEnter === 0) {\n            this.removePointerHover(dragPointerId);\n        }\n    }\n    @HostListener('drop' , ['$event']) BrowserDrop (event : MouseEvent) {\n        // console.log( 'BrowserDrop', this, event );\n        DM.pointerRelease( dragPointerId );\n        this.nbDragEnter = 0;\n        this.onDropEmitter.emit( event );\n    }\n    drop( obj ) {\n        // console.log( this, 'drop', obj );\n        this.onDropEmitter.emit( obj );\n    }\n    checkAccept(drag: Draggable | DragEvent) : boolean {\n        let res: boolean;\n        if( drag instanceof Draggable ) {\n            res = this.acceptFunction?this.acceptFunction( drag.draggedData ):true;\n        } else {\n            res = this.acceptFunction?this.acceptFunction( drag ):true;\n        }\n        return res;\n    }\n    hasPointerHover(idPointer: string) {\n        return this.pointersHover.indexOf(idPointer) >= 0;\n    }\n    appendPointerHover( idPointer: string ) {\n        if( this.pointersHover.indexOf(idPointer) === -1 ) {\n            let dragged = DM.draggedStructures.get(idPointer);\n            this.pointersHover.push(idPointer);\n            if(dragged instanceof Draggable) {\n                if(this.dragOverCSS_pointer) {\n                    dragged.getClone().classList.add( this.dragOverCSS_pointer );\n                }\n                this.onDragEnter.emit( dragged.draggedData );\n            } else {\n                this.onDragEnter.emit( dragged );\n            }\n            if(this.dragOverCSS) {\n                this.root.classList.add( this.dragOverCSS );\n            }\n        }\n    }\n    removePointerHover( idPointer: string ) {\n        let pos = this.pointersHover.indexOf(idPointer);\n        if( pos >= 0 ) {\n            let dragged = DM.draggedStructures.get(idPointer);\n            this.pointersHover.splice(pos, 1);\n            if(dragged instanceof Draggable) {\n                if(this.dragOverCSS_pointer) {\n                    dragged.getClone().classList.remove( this.dragOverCSS_pointer );\n                }\n                this.onDragLeave.emit( dragged.draggedData );\n            } else {\n                this.onDragLeave.emit( dragged );\n            }\n            if(this.pointersHover.length === 0 && this.dragOverCSS) {\n                this.root.classList.remove( this.dragOverCSS );\n            }\n        }\n    }\n    appendDropCandidatePointer( idPointer: string ) {\n        // console.log( 'appendDropCandidatePointer', idPointer, this );\n        if( this.dropCandidateofPointers.indexOf(idPointer) === -1 ) {\n            let dragged = DM.draggedStructures.get(idPointer);\n            if(dragged instanceof Draggable) {\n                this.onDragStart.emit( dragged.draggedData );\n            } else {\n                this.onDragStart.emit( dragged );\n            }\n            this.dropCandidateofPointers.push( idPointer );\n            if(this.dragCSS) {\n                this.root.classList.add( this.dragCSS );\n            }\n        }\n    }\n    removeDropCandidatePointer( idPointer: string ) {\n        let pos = this.dropCandidateofPointers.indexOf(idPointer);\n        if( pos >= 0 ) {\n            let dragged = DM.draggedStructures.get(idPointer);\n            if(dragged instanceof Draggable) {\n                this.onDragEnd.emit( dragged.draggedData );\n            } else {\n                this.onDragEnd.emit( dragged );\n            }\n            this.dropCandidateofPointers.splice(pos, 1);\n            if(this.dropCandidateofPointers.length === 0 && this.dragCSS) {\n                this.root.classList.remove( this.dragCSS );\n            }\n        }\n    }\n}\n",
    "import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { Draggable, Dropzone, DragDrop }  from './ngx-drag-and-drop.directive';\n\n@NgModule({\n  imports: [\n    CommonModule,\n  ],\n  declarations: [\n    Draggable,\n    Dropzone,\n    DragDrop,\n  ],\n  exports: [\n    Draggable,\n    Dropzone,\n    DragDrop,\n  ]\n})\nexport class NgxDragAndDropModule {\n  static forRoot() {\n      return {\n          ngModule: NgxDragAndDropModule,\n          providers: []\n      };\n  }\n}\n"
  ],
  "names": [
    "myDoc",
    "elementsFromPoint",
    "x",
    "y",
    "element",
    "elements",
    "old_visibility",
    "document",
    "elementFromPoint",
    "documentElement",
    "push",
    "style",
    "visibility",
    "k",
    "length",
    "dragPointerId",
    "DM",
    "this",
    "draggingPointer",
    "Map",
    "draggedStructures",
    "dropZones",
    "DragManager",
    "prototype",
    "preStartDrag",
    "idPointer",
    "dragged",
    "delay",
    "dist",
    "_this",
    "set",
    "Promise",
    "resolve",
    "reject",
    "setTimeout",
    "ptr",
    "get",
    "gogo",
    "Math",
    "abs",
    "delete",
    "max",
    "startDrag",
    "possibleDropZones",
    "forEach",
    "dz",
    "checkAccept",
    "appendDropCandidatePointer",
    "root",
    "isAssociatedToDropZone",
    "has",
    "registerDropZone",
    "dropzone",
    "unregisterDropZone",
    "pointerMove",
    "Draggable",
    "move",
    "undefined",
    "pointerRelease",
    "stop",
    "dragDropInit",
    "DragDrop",
    "nbDragEnter",
    "console",
    "error",
    "removeFeedbackForDragPointer",
    "removePointerHover",
    "removeDropCandidatePointer",
    "drop",
    "e",
    "preventDefault",
    "stopPropagation",
    "dragover",
    "dragenter",
    "dragleave",
    "dragend",
    "mousemove",
    "clientX",
    "clientY",
    "mouseup",
    "touchmove",
    "i",
    "changedTouches",
    "touch",
    "item",
    "identifier",
    "toString",
    "touchend",
    "type",
    "Directive",
    "args",
    "selector",
    "HostListener",
    "el",
    "disabled",
    "onDragStart",
    "EventEmitter",
    "onDragEnd",
    "isBeingDragged",
    "cloneNode",
    "nativeElement",
    "ngOnInit",
    "ngOnDestroy",
    "onMouseDown",
    "event",
    "log",
    "prestart",
    "onTouchStart",
    "startDelay",
    "startDistance",
    "then",
    "start",
    "offset",
    "left",
    "top",
    "offsetTop",
    "scrollTop",
    "clientTop",
    "offsetLeft",
    "scrollLeft",
    "clientLeft",
    "offsetElement",
    "ox",
    "oy",
    "dx",
    "dy",
    "tx",
    "offsetWidth",
    "ty",
    "offsetHeight",
    "getClone",
    "emit",
    "draggedData",
    "clear",
    "currentDropZone",
    "deleteClone",
    "prevDropZone",
    "appendPointerHover",
    "deepStyle",
    "original",
    "clone",
    "HTMLElement",
    "window",
    "getComputedStyle",
    "att",
    "children",
    "parentNode",
    "removeChild",
    "body",
    "appendChild",
    "position",
    "zIndex",
    "marginLeft",
    "marginTop",
    "marginRight",
    "marginBottom",
    "opacity",
    "cursor",
    "transform",
    "transformOrigin",
    "animation",
    "transition",
    "classList",
    "add",
    "ElementRef",
    "Input",
    "Output",
    "Dropzone",
    "onDropEmitter",
    "onDragEnter",
    "onDragLeave",
    "dropCandidateofPointers",
    "pointersHover",
    "BrowserDragEnter",
    "BrowserDragLeave",
    "BrowserDrop",
    "obj",
    "drag",
    "acceptFunction",
    "hasPointerHover",
    "indexOf",
    "dragOverCSS_pointer",
    "dragOverCSS",
    "pos",
    "splice",
    "remove",
    "dragCSS",
    "NgxDragAndDropModule",
    "forRoot",
    "ngModule",
    "providers",
    "NgModule",
    "imports",
    "CommonModule",
    "declarations",
    "exports"
  ],
  "mappings": "uTAIS,IAAIA,EAAK,SAGhBA,EAAMC,kBAAoBD,EAAMC,mBAAqB,SAASC,EAAUC,GAGtE,IAFA,IAAIC,EAASC,KACTC,MAEAF,EAAUG,SAASC,iBAAiBN,EAAGC,KACvBC,IAAYG,SAASE,iBAGrCJ,EAASK,KAAKN,GACdE,EAAeI,KAAKN,EAAQO,MAAMC,YAClCR,EAAQO,MAAMC,WAAa,SAE/B,IAAK,IAAIC,EAAI,EAAGA,EAAIR,EAASS,OAAQD,IACjCR,EAASQ,GAAGF,MAAMC,WAAaN,EAAeO,GAElD,OAAOR,GCHX,IAAMU,EAAgB,cA8DlBC,EAAK,IA5DT,wBACAC,KAAAC,gBAA0B,IAAIC,IAC9BF,KAAAG,kBAA0B,IAAID,IAC9BF,KAAAI,UAA0B,IAAIF,IAwD9B,OAtDIG,EAAJC,UAAAC,aAAI,SAAcC,EAAmBC,EAAoBxB,EAAWC,EAClDwB,EAAeC,GAD7B,IAAJC,EAAAZ,KAIQ,OADAA,KAAKC,gBAAkBY,IAAIL,GAAYvB,EAAGA,EAAGC,EAAGA,IACzC,IAAI4B,QAAe,SAACC,EAASC,GAChCC,WAAW,WACP,IAAIC,EAAQN,EAAKX,gBAAgBkB,IAAIX,GACjCY,EAAQF,GAAQG,KAAKC,IAAIrC,EAAIiC,EAAIjC,GAAKoC,KAAKC,IAAIpC,EAAIgC,EAAIhC,GAAMyB,EACjEC,EAAKX,gBAAgBsB,UAAOf,GACzBY,EAAOL,IAAkBC,KAC7BK,KAAKG,IAAI,EAAGd,OAGhBL,EAAXC,UAAAmB,UAAW,SAAUjB,EAAmBC,EAAgCxB,EAAWC,GAE3Ec,KAAKG,kBAAkBU,IAAIL,EAAWC,GACtC,IAAIiB,EAAoB,IAAIxB,IAO5B,OANAF,KAAKI,UAAUuB,QAAS,SAAAC,GAChBA,EAAGC,YAAYpB,KACfmB,EAAGE,2BAA4BtB,GAC/BkB,EAAkBb,IAAIe,EAAGG,KAAMH,MAGhCF,GAEJrB,EAAXC,UAAA0B,uBAAW,SAAuB7C,GAC1B,OAAOa,KAAKI,UAAU6B,IAAK9C,IAExBkB,EAAXC,UAAA4B,iBAAW,SAAkBC,GACrBnC,KAAKI,UAAUS,IAAIsB,EAASJ,KAAMI,IAE/B9B,EAAXC,UAAA8B,mBAAW,SAAoBD,GACvBnC,KAAKI,UAAUmB,UAAOY,EAASJ,OAE5B1B,EAAXC,UAAA+B,YAAW,SAAY7B,EAAmBvB,EAAWC,GAC7C,IAAIgC,EAAMlB,KAAKC,gBAAgBkB,IAAIX,GAChCU,IAAMA,EAAIjC,EAAIA,EAAGiC,EAAIhC,EAAIA,GAC5B,IAAIuB,EAAUT,KAAKG,kBAAkBgB,IAAIX,GAIzC,OAHGC,GAAWA,aAAmB6B,GAC7B7B,EAAQ8B,KAAKtD,EAAGC,GAEbuB,IAAY+B,WAEhBnC,EAAXC,UAAAmC,eAAW,SAAejC,GAClB,IAAIC,EAAUT,KAAKG,kBAAkBgB,IAAIX,GAQzC,OAPGC,GACIA,aAAmB6B,GAClB7B,EAAQiC,OAGhB1C,KAAKG,kBAAkBoB,UAAOf,GAC9BR,KAAKC,gBAAkBsB,UAAOf,GACvBC,IAAY+B,WAE3BnC,EA3DA,IA8DIsC,GAAe,EAMnBC,EAAA,WAEI,SAAJA,IADA5C,KAAA6C,YAAkB,EAEPF,EACCG,QAAQC,MAAO,wEAEfJ,GAAe,SAGvBC,EAAJtC,UAAA0C,6BAAI,WACIhD,KAAK6C,YAAc,EACnB9C,EAAGK,UAAUuB,QAAS,SAAAC,GAClBA,EAAGqB,mBAA8BnD,GACjC8B,EAAGsB,2BAA8BpD,MAGK8C,EAAlDtC,UAAA6C,KAAkD,SAAMC,GAEhDA,EAAEC,iBACFD,EAAEE,kBACFtD,KAAKgD,gCAEyCJ,EAAtDtC,UAAAiD,SAAsD,SAAUH,GAExDA,EAAEC,iBACFD,EAAEE,mBAE6CV,EAAvDtC,UAAAkD,UAAuD,SAAWJ,GAC1DpD,KAAK6C,cACmB,IAArB7C,KAAK6C,aACJ9C,EAAG0B,UAAU3B,EAAesD,GAAI,GAAI,IAGOR,EAAvDtC,UAAAmD,UAAuD,SAAWL,GAC1DpD,KAAK6C,cACmB,IAArB7C,KAAK6C,cACJ7C,KAAKgD,+BACLjD,EAAG0C,eAAgB3C,KAGsB8C,EAArDtC,UAAAoD,QAAqD,SAASN,GACtDrD,EAAG0C,eAAgB3C,GACnBE,KAAKgD,+BACLI,EAAEC,kBAE6CT,EAAvDtC,UAAAqD,UAAuD,SAAWP,GAC1DrD,EAAGsC,YAAe,QAASe,EAAEQ,QAASR,EAAES,UAEOjB,EAAvDtC,UAAAwD,QAAuD,SAAWV,GAC1DrD,EAAG0C,eAAe,UAE6BG,EAAvDtC,UAAAyD,UAAuD,SAAWX,GAC1D,IAAK,IAAIY,EAAI,EAAGA,EAAIZ,EAAEa,eAAepE,OAAQmE,IAAK,CAC9C,IAAIE,EAAcd,EAAEa,eAAeE,KAAKH,GACpCjE,EAAGsC,YAAY6B,EAAME,WAAWC,WAAYH,EAAMN,QAASM,EAAML,WACjET,EAAEC,iBACFD,EAAEE,qBAIqCV,EAAvDtC,UAAAgE,SAAuD,SAAWlB,GAC1D,IAAI,IAAIY,EAAE,EAAGA,EAAEZ,EAAEa,eAAepE,OAAQmE,IAAK,CACzC,IAAIE,EAAgBd,EAAEa,eAAeE,KAAKH,GACtCjE,EAAG0C,eAAeyB,EAAME,WAAWC,cACnCjB,EAAEC,iBACFD,EAAEE,uBAjElB,kBAHAiB,KAACC,EAAAA,UAADC,OACIC,SAAU,uFAkBdvB,OAAAoB,KAAKI,EAAAA,aAALF,MAAmB,kBAAmB,aAMtClB,WAAAgB,KAAKI,EAAAA,aAALF,MAAmB,sBAAuB,aAK1CjB,YAAAe,KAAKI,EAAAA,aAALF,MAAmB,uBAAwB,aAM3ChB,YAAAc,KAAKI,EAAAA,aAALF,MAAmB,uBAAwB,aAO3Cf,UAAAa,KAAKI,EAAAA,aAALF,MAAmB,qBAAsB,aAKzCd,YAAAY,KAAKI,EAAAA,aAALF,MAAmB,uBAAwB,aAG3CX,UAAAS,KAAKI,EAAAA,aAALF,MAAmB,qBAAwB,aAG3CV,YAAAQ,KAAKI,EAAAA,aAALF,MAAmB,uBAAwB,aAS3CH,WAAAC,KAAKI,EAAAA,aAALF,MAAmB,sBAAwB,cAW3C,IAaAnC,EAAA,WAmBI,SAAJA,EAAgBsC,GAfhB5E,KAAA6E,UAA4C,EAC5C7E,KAAA8E,YAAwC,IAAIC,EAAAA,aAC5C/E,KAAAgF,UAAwC,IAAID,EAAAA,aAC5C/E,KAAAiF,gBAAsD,EACtDjF,KAAAkF,UAA0D,KAE1DlF,KAAA0B,kBAAgC,IAAIxB,IAU5BF,KAAK+B,KAAO6C,EAAGO,cACXxC,GACDG,QAAQC,MAAM,oFAIrBT,EAAJhC,UAAA8E,SAAI,aAGA9C,EAAJhC,UAAA+E,YAAI,aAGwC/C,EAA5ChC,UAAAgF,YAA4C,SAAaC,GAEjDzC,QAAQ0C,IAAIxF,KAAK6E,UACZ7E,KAAK6E,WACNU,EAAMlC,iBACNkC,EAAMjC,kBACNtD,KAAKyF,SAAS,QAASF,EAAM3B,QAAS2B,EAAM1B,WAGZvB,EAA5ChC,UAAAoF,aAA4C,SAAaH,GAGjDA,EAAMjC,kBACN,IAAI,IAAIU,EAAE,EAAGA,EAAEuB,EAAMtB,eAAepE,OAAQmE,IAAK,CAC7C,IAAIE,EAAgBqB,EAAMtB,eAAeE,KAAKH,GAC9ChE,KAAKyF,SAASvB,EAAME,WAAWC,WAAYH,EAAMN,QAASM,EAAML,WAGxEvB,EAAJhC,UAAAmF,SAAI,SAASjF,EAAmBvB,EAAWC,GAAvC,IAAJ0B,EAAAZ,KACQD,EAAGQ,aAAaC,EAAWR,KAAMf,EAAGC,EAAGc,KAAK2F,YAAc,EAAG3F,KAAK4F,eAAiB,IAAIC,KACnF,WACIjF,EAAKkF,MAAMtF,EAAWvB,EAAGC,IAE7B,eAKRoD,EAAJhC,UAAAwF,MAAI,SAAMtF,EAAmBvB,EAAWC,GAChC,IAAKc,KAAKiF,eAAiB,CACvBjF,KAAKiF,gBAAiB,EACtBjF,KAAKQ,UAAYA,EAEjB,IAAIuF,EA9EI,SAAC5G,GAEjB,IADA,IAAI6G,EAAO,EAAGC,EAAM,EACb9G,GACH8G,GAAQ9G,EAAQ+G,UAAa/G,EAAQgH,UAAahH,EAAQiH,UAC1DJ,GAAQ7G,EAAQkH,WAAalH,EAAQmH,WAAanH,EAAQoH,WAC1DpH,EAAUA,EAAmC,aAEjD,OAAQ6G,KAAMA,EAAMC,IAAKA,GAuEJO,CAAcxG,KAAK+B,MAChC/B,KAAKyG,GAAKxH,EAAGe,KAAK0G,GAAKxH,EACvBc,KAAK2G,GAAK1H,EAAI8G,EAAOC,KACrBhG,KAAK4G,GAAK1H,EAAI6G,EAAOE,IAOrBjG,KAAK6G,GAAK7G,KAAK+B,KAAK+E,YACpB9G,KAAK+G,GAAK/G,KAAK+B,KAAKiF,aAEpBhH,KAAKiH,WACLjH,KAAKkF,UAAUxF,MAAMsG,KAAQ/G,EAAIe,KAAK2G,GAAiC,KACvE3G,KAAKkF,UAAUxF,MAAMuG,IAAQ/G,EAAIc,KAAK4G,GAAiC,KACvE5G,KAAK8E,YAAYoC,KAAMlH,KAAKmH,aAC5BnH,KAAK0B,kBAAoB3B,EAAG0B,UAAUjB,EAAWR,KAAMf,EAAGC,KAGlEoD,EAAJhC,UAAAoC,KAAI,WAAA,IAAJ9B,EAAAZ,KACQA,KAAK0B,kBAAkBC,QAAS,SAAAC,GAC5BA,EAAGqB,mBAA8BrC,EAAKJ,WACtCoB,EAAGsB,2BAA8BtC,EAAKJ,aAE1CR,KAAKiF,gBAAiB,EACtBjF,KAAK0B,kBAAkB0F,QACvBpH,KAAKQ,UAAY,KACdR,KAAKqH,iBACJrH,KAAKqH,gBAAgBlE,KAAMnD,KAAKmH,aAEpCnH,KAAKqH,gBAAkB,KACvBrH,KAAKgF,UAAUkC,KAAMlH,KAAKmH,aAC1BnH,KAAKsH,eAEThF,EAAJhC,UAAAiC,KAAI,SAAKtD,EAAWC,GACZ,IAAIC,EAAoB,KAIxB,GAHsB,OAAnBa,KAAKkF,WACJlF,KAAKiH,WAENjH,KAAKkF,UAAW,CACflF,KAAKkF,UAAUxF,MAAMsG,KAAQ/G,EAAIe,KAAK2G,GAAiC,KACvE3G,KAAKkF,UAAUxF,MAAMuG,IAAQ/G,EAAIc,KAAK4G,GAAiC,KAEvE,IAAIjH,EAAaK,KAAKkF,UAAUxF,MAAMC,WAEtCK,KAAKkF,UAAUxF,MAAMC,WAAa,SAClC,IAAIsG,EAAMjG,KAAKkF,UAAUxF,MAAMuG,IAC/BjG,KAAKkF,UAAUxF,MAAMuG,IAAM,cAG3B9G,EAAUJ,EAAMQ,iBAAiBN,EAAGC,GAEpCc,KAAKkF,UAAUxF,MAAMuG,IAAMA,EAC3BjG,KAAKkF,UAAUxF,MAAMC,WAAaA,EAIlC,IADA,IAAI4H,EAAevH,KAAKqH,gBAClBlI,IAEFa,KAAKqH,gBAAkBrH,KAAK0B,kBAAkBP,IAAKhC,IAChDa,KAAKqH,kBACRlI,EAAmBA,EAAqB,cAEzCoI,IAAiBvH,KAAKqH,kBAClBE,GACCA,EAAatE,mBAAoBjD,KAAKQ,WAEvCR,KAAKqH,iBACJrH,KAAKqH,gBAAgBG,mBAAoBxH,KAAKQ,YAc1D,OAAOR,MAEXsC,EAAJhC,UAAAmH,UAAI,SAAUC,EAAmBC,GACzB,GAAGD,aAAoBE,YAAa,CAEhC,IADA,IAAIlI,EAAQmI,OAAOC,iBAAiBJ,GAC3B1D,EAAI,EAAGA,EAAItE,EAAMG,OAAQmE,IAAK,CACnC,IAAI+D,EAAMrI,EAAMsE,GAChB,EAAuBtE,MAAMqI,GAAOrI,EAAMqI,GAE9C,IAAQ/D,EAAE,EAAGA,EAAE0D,EAASM,SAASnI,OAAQmE,IACrChE,KAAKyH,UAAUC,EAASM,SAAS7D,KAAKH,GAAI,EAAuBgE,SAAS7D,KAAKH,MAI3F1B,EAAJhC,UAAAgH,YAAI,WACOtH,KAAKkF,YACDlF,KAAKkF,UAAU+C,YACdjI,KAAKkF,UAAU+C,WAAWC,YAAYlI,KAAKkF,WAE/ClF,KAAKkF,UAAY,OAGzB5C,EAAJhC,UAAA2G,SAAI,WAuBI,OAtBsB,OAAnBjH,KAAKkF,YACJlF,KAAKkF,UAAyBlF,KAAK+B,KAAKmD,WAAU,GAElDlF,KAAKyH,UAAWzH,KAAK+B,KAAM/B,KAAKkF,WAGhC5F,SAAS6I,KAAKC,YAAapI,KAAKkF,WAChClF,KAAKkF,UAAUxF,MAAM2I,SAAkB,WACvCrI,KAAKkF,UAAUxF,MAAM4I,OAAkB,MACvCtI,KAAKkF,UAAUxF,MAAM6I,WAAkB,IACvCvI,KAAKkF,UAAUxF,MAAM8I,UAAkB,IACvCxI,KAAKkF,UAAUxF,MAAM+I,YAAkB,IACvCzI,KAAKkF,UAAUxF,MAAMgJ,aAAkB,IACvC1I,KAAKkF,UAAUxF,MAAMiJ,QAAkB,GACvC3I,KAAKkF,UAAUxF,MAAMkJ,OAAkB,GACvC5I,KAAKkF,UAAUxF,MAAMmJ,UAAkB,GACvC7I,KAAKkF,UAAUxF,MAAMoJ,gBAAkB,GACvC9I,KAAKkF,UAAUxF,MAAMqJ,UAAkB,GACvC/I,KAAKkF,UAAUxF,MAAMsJ,WAAkB,GACvChJ,KAAKkF,UAAU+D,UAAUC,IAAK,6BAG3BlJ,KAAKkF,aAjMpB,kBAHAX,KAACC,EAAAA,UAADC,OACIC,SAAU,uDA3KdH,KAAoB4E,EAAAA,gCA8KpBhC,cAAA5C,KAAK6E,EAAAA,MAAL3E,MAAY,eACZkB,aAAApB,KAAK6E,EAAAA,MAAL3E,MAAY,sBACZmB,gBAAArB,KAAK6E,EAAAA,MAAL3E,MAAY,oBACZI,WAAAN,KAAK6E,EAAAA,MAAL3E,MAAY,cACZK,cAAAP,KAAK8E,EAAAA,OAAL5E,MAAY,gBACZO,YAAAT,KAAK8E,EAAAA,OAAL5E,MAAY,cA0BZa,cAAAf,KAAKI,EAAAA,aAALF,MAAkB,aAAe,aASjCiB,eAAAnB,KAAKI,EAAAA,aAALF,MAAkB,cAAe,cA6JjC,IAAA6E,EAAA,WAgBI,SAAJA,EAAgB1E,GAfhB5E,KAAA6C,YAAkB,EAMlB7C,KAAAuJ,cAA0C,IAAIxE,EAAAA,aAC9C/E,KAAA8E,YAA0C,IAAIC,EAAAA,aAC9C/E,KAAAgF,UAA0C,IAAID,EAAAA,aAC9C/E,KAAAwJ,YAA0C,IAAIzE,EAAAA,aAC9C/E,KAAAyJ,YAA0C,IAAI1E,EAAAA,aAG9C/E,KAAA0J,2BACA1J,KAAA2J,iBAEYhH,GACAG,QAAQC,MAAM,4EAElB/C,KAAK+B,KAAO6C,EAAGO,cAEfpF,EAAGmC,iBAAiBlC,aAExBsJ,EAAJhJ,UAAA8E,SAAI,aAGAkE,EAAJhJ,UAAA+E,YAAI,WAEItF,EAAGqC,mBAAoBpC,OAEasJ,EAA5ChJ,UAAAsJ,iBAA4C,SAAkBrE,GAEtDvF,KAAK6C,cACmB,IAArB7C,KAAK6C,aACJ7C,KAAKwH,mBAAmB1H,IAGQwJ,EAA5ChJ,UAAAuJ,iBAA4C,SAAkBtE,GAEtDvF,KAAK6C,cACmB,IAArB7C,KAAK6C,aACJ7C,KAAKiD,mBAAmBnD,IAGGwJ,EAAvChJ,UAAAwJ,YAAuC,SAAavE,GAE5CxF,EAAG0C,eAAgB3C,GACnBE,KAAK6C,YAAc,EACnB7C,KAAKuJ,cAAcrC,KAAM3B,IAE7B+D,EAAJhJ,UAAA6C,KAAI,SAAM4G,GAEF/J,KAAKuJ,cAAcrC,KAAM6C,IAE7BT,EAAJhJ,UAAAuB,YAAI,SAAYmI,GAOR,OALIA,aAAgB1H,GACVtC,KAAKiK,gBAAejK,KAAKiK,eAAgBD,EAAK7C,cAE9CnH,KAAKiK,gBAAejK,KAAKiK,eAAgBD,IAIvDV,EAAJhJ,UAAA4J,gBAAI,SAAgB1J,GACZ,OAAgD,GAAzCR,KAAK2J,cAAcQ,QAAQ3J,IAEtC8I,EAAJhJ,UAAAkH,mBAAI,SAAoBhH,GAChB,IAA+C,IAA3CR,KAAK2J,cAAcQ,QAAQ3J,GAAoB,CAC/C,IAAIC,EAAUV,EAAGI,kBAAkBgB,IAAIX,GACvCR,KAAK2J,cAAclK,KAAKe,GACrBC,aAAmB6B,GACftC,KAAKoK,qBACJ3J,EAAQwG,WAAWgC,UAAUC,IAAKlJ,KAAKoK,qBAE3CpK,KAAKwJ,YAAYtC,KAAMzG,EAAQ0G,cAE/BnH,KAAKwJ,YAAYtC,KAAMzG,GAExBT,KAAKqK,aACJrK,KAAK+B,KAAKkH,UAAUC,IAAKlJ,KAAKqK,eAI1Cf,EAAJhJ,UAAA2C,mBAAI,SAAoBzC,GAChB,IAAI8J,EAAMtK,KAAK2J,cAAcQ,QAAQ3J,GACrC,GAAW,GAAP8J,EAAW,CACX,IAAI7J,EAAUV,EAAGI,kBAAkBgB,IAAIX,GACvCR,KAAK2J,cAAcY,OAAOD,EAAK,GAC5B7J,aAAmB6B,GACftC,KAAKoK,qBACJ3J,EAAQwG,WAAWgC,UAAUuB,OAAQxK,KAAKoK,qBAE9CpK,KAAKyJ,YAAYvC,KAAMzG,EAAQ0G,cAE/BnH,KAAKyJ,YAAYvC,KAAMzG,GAEM,IAA9BT,KAAK2J,cAAc9J,QAAgBG,KAAKqK,aACvCrK,KAAK+B,KAAKkH,UAAUuB,OAAQxK,KAAKqK,eAI7Cf,EAAJhJ,UAAAwB,2BAAI,SAA4BtB,GAExB,IAAyD,IAArDR,KAAK0J,wBAAwBS,QAAQ3J,GAAoB,CACzD,IAAIC,EAAUV,EAAGI,kBAAkBgB,IAAIX,GACpCC,aAAmB6B,EAClBtC,KAAK8E,YAAYoC,KAAMzG,EAAQ0G,aAE/BnH,KAAK8E,YAAYoC,KAAMzG,GAE3BT,KAAK0J,wBAAwBjK,KAAMe,GAChCR,KAAKyK,SACJzK,KAAK+B,KAAKkH,UAAUC,IAAKlJ,KAAKyK,WAI1CnB,EAAJhJ,UAAA4C,2BAAI,SAA4B1C,GACxB,IAAI8J,EAAMtK,KAAK0J,wBAAwBS,QAAQ3J,GAC/C,GAAW,GAAP8J,EAAW,CACX,IAAI7J,EAAUV,EAAGI,kBAAkBgB,IAAIX,GACpCC,aAAmB6B,EAClBtC,KAAKgF,UAAUkC,KAAMzG,EAAQ0G,aAE7BnH,KAAKgF,UAAUkC,KAAMzG,GAEzBT,KAAK0J,wBAAwBa,OAAOD,EAAK,GACE,IAAxCtK,KAAK0J,wBAAwB7J,QAAgBG,KAAKyK,SACjDzK,KAAK+B,KAAKkH,UAAUuB,OAAQxK,KAAKyK,aAhIjD,kBADAlG,KAACC,EAAAA,UAADC,OAAaC,SAAU,sDAlXvBH,KAAoB4E,EAAAA,gCAsXpBsB,UAAAlG,KAAK6E,EAAAA,MAAL3E,MAAW,cACX4F,cAAA9F,KAAK6E,EAAAA,MAAL3E,MAAW,mBACX2F,sBAAA7F,KAAK6E,EAAAA,MAAL3E,MAAW,iCACXwF,iBAAA1F,KAAK6E,EAAAA,MAAL3E,MAAW,qBACX8E,gBAAAhF,KAAK8E,EAAAA,OAAL5E,MAAY,YACZK,cAAAP,KAAK8E,EAAAA,OAAL5E,MAAY,gBACZO,YAAAT,KAAK8E,EAAAA,OAAL5E,MAAY,cACZ+E,cAAAjF,KAAK8E,EAAAA,OAAL5E,MAAY,gBACZgF,cAAAlF,KAAK8E,EAAAA,OAAL5E,MAAY,gBAoBZmF,mBAAArF,KAAKI,EAAAA,aAALF,MAAkB,aAAe,aAOjCoF,mBAAAtF,KAAKI,EAAAA,aAALF,MAAkB,aAAe,aAOjCqF,cAAAvF,KAAKI,EAAAA,aAALF,MAAkB,QAAU,cCha5B,IAAAiG,EAAA,WAAA,SAAAA,YAqBSA,EAATC,QAAE,WACI,OACIC,SAAUF,EACVG,iBAxBV,kBAKAtG,KAACuG,EAAAA,SAADrG,OACEsG,SACEC,EAAAA,cAEFC,cACE3I,EACAgH,EACA1G,GAEFsI,SACE5I,EACAgH,EACA1G"
}
