import { Directive, ElementRef, Input, HostListener, EventEmitter, Output, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

let myDoc = /** @type {?} */ (document);
//(<MyDocument>document).elementsFromPoint = (<MyDocument>document).elementsFromPoint ||
myDoc.elementsFromPoint = myDoc.elementsFromPoint || function (x, y) {
    let /** @type {?} */ element, /** @type {?} */ elements = [];
    let /** @type {?} */ old_visibility = [];
    while (true) {
        element = document.elementFromPoint(x, y);
        if (!element || element === document.documentElement) {
            break;
        }
        elements.push(element);
        old_visibility.push(element.style.visibility);
        element.style.visibility = 'hidden'; // Temporarily hide the element (without changing the layout)
    }
    for (let /** @type {?} */ k = 0; k < elements.length; k++) {
        elements[k].style.visibility = old_visibility[k];
    }
    return elements;
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

/*
interface ShadowRoot extends DocumentFragment {
    styleSheets     : StyleSheetList;
    innerHTML       : string;
    host            : Element;
    activeElement   : Element;
    elementFromPoint        (x : number, y : number) : Element;
    elementsFromPoint       (x : number, y : number) : Element[];
    caretPositionFromPoint  (x : number, y : number); // => CaretPosition
};
interface ElementWithShadowRoot extends HTMLElement {
    shadowRoot  : ShadowRoot;
};*/
const dragPointerId = 'dragPointer';
class DragManager {
    constructor() {
        this.draggingPointer = new Map();
        this.draggedStructures = new Map();
        this.dropZones = new Map();
    }
    /**
     * @param {?} idPointer
     * @param {?} dragged
     * @param {?} x
     * @param {?} y
     * @param {?} delay
     * @param {?} dist
     * @return {?}
     */
    preStartDrag(idPointer, dragged, x, y, delay, dist) {
        // console.log('preStartDrag', idPointer, dragged, x, y, delay);
        this.draggingPointer.set(idPointer, { x: x, y: y });
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                let /** @type {?} */ ptr = this.draggingPointer.get(idPointer);
                let /** @type {?} */ gogo = ptr && (Math.abs(x - ptr.x) + Math.abs(y - ptr.y)) < dist;
                this.draggingPointer.delete(idPointer);
                if (gogo) {
                    resolve();
                }
                else {
                    reject();
                }
            }, Math.max(0, delay));
        }); // End of Promise
    }
    /**
     * @param {?} idPointer
     * @param {?} dragged
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    startDrag(idPointer, dragged, x, y) {
        // console.log('startdrag', dragged, x, y);
        this.draggedStructures.set(idPointer, dragged);
        let /** @type {?} */ possibleDropZones = new Map();
        this.dropZones.forEach(dz => {
            if (dz.checkAccept(dragged)) {
                dz.appendDropCandidatePointer(idPointer);
                possibleDropZones.set(dz.root, dz);
            }
        });
        return possibleDropZones;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    isAssociatedToDropZone(element) {
        return this.dropZones.has(element);
    }
    /**
     * @param {?} dropzone
     * @return {?}
     */
    registerDropZone(dropzone) {
        this.dropZones.set(dropzone.root, dropzone);
    }
    /**
     * @param {?} dropzone
     * @return {?}
     */
    unregisterDropZone(dropzone) {
        this.dropZones.delete(dropzone.root);
    }
    /**
     * @param {?} idPointer
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    pointerMove(idPointer, x, y) {
        let /** @type {?} */ ptr = this.draggingPointer.get(idPointer);
        if (ptr) {
            ptr.x = x;
            ptr.y = y;
        }
        let /** @type {?} */ dragged = this.draggedStructures.get(idPointer);
        if (dragged && dragged instanceof Draggable) {
            dragged.move(x, y);
        }
        return dragged !== undefined;
    }
    /**
     * @param {?} idPointer
     * @return {?}
     */
    pointerRelease(idPointer) {
        let /** @type {?} */ dragged = this.draggedStructures.get(idPointer);
        if (dragged) {
            if (dragged instanceof Draggable) {
                dragged.stop();
            }
        }
        this.draggedStructures.delete(idPointer);
        this.draggingPointer.delete(idPointer);
        return dragged !== undefined;
    }
}
let DM = new DragManager();
let dragDropInit = false;
class DragDrop {
    constructor() {
        this.nbDragEnter = 0;
        if (dragDropInit) {
            console.error('Do not create multiple instance of directive drag-and-drop-wrapper !');
        }
        else {
            dragDropInit = true;
        }
    }
    /**
     * @return {?}
     */
    removeFeedbackForDragPointer() {
        this.nbDragEnter = 0;
        DM.dropZones.forEach(dz => {
            dz.removePointerHover(dragPointerId);
            dz.removeDropCandidatePointer(dragPointerId);
        });
    }
    /**
     * @param {?} e
     * @return {?}
     */
    drop(e) {
        // console.log( 'document drop', e );
        e.preventDefault();
        e.stopPropagation();
        this.removeFeedbackForDragPointer();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    dragover(e) {
        // console.log( 'document dragover', e );
        e.preventDefault();
        e.stopPropagation();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    dragenter(e) {
        this.nbDragEnter++;
        if (this.nbDragEnter === 1) {
            DM.startDrag(dragPointerId, e, -1, -1);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    dragleave(e) {
        this.nbDragEnter--;
        if (this.nbDragEnter === 0) {
            this.removeFeedbackForDragPointer();
            DM.pointerRelease(dragPointerId);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    dragend(e) {
        DM.pointerRelease(dragPointerId);
        this.removeFeedbackForDragPointer();
        e.preventDefault();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    mousemove(e) {
        DM.pointerMove('mouse', e.clientX, e.clientY);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    mouseup(e) {
        DM.pointerRelease('mouse');
    }
    /**
     * @param {?} e
     * @return {?}
     */
    touchmove(e) {
        for (let /** @type {?} */ i = 0; i < e.changedTouches.length; i++) {
            let /** @type {?} */ touch = e.changedTouches.item(i);
            if (DM.pointerMove(touch.identifier.toString(), touch.clientX, touch.clientY)) {
                e.preventDefault();
                e.stopPropagation();
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    touchend(e) {
        for (let /** @type {?} */ i = 0; i < e.changedTouches.length; i++) {
            let /** @type {?} */ touch = e.changedTouches.item(i);
            if (DM.pointerRelease(touch.identifier.toString())) {
                e.preventDefault();
                e.stopPropagation();
            }
        }
    }
}
DragDrop.decorators = [
    { type: Directive, args: [{
                selector: '*[drag-and-drop-wrapper]'
            },] },
];
/** @nocollapse */
DragDrop.ctorParameters = () => [];
DragDrop.propDecorators = {
    "drop": [{ type: HostListener, args: ['document: drop', ['$event'],] },],
    "dragover": [{ type: HostListener, args: ['document: dragover', ['$event'],] },],
    "dragenter": [{ type: HostListener, args: ['document: dragenter', ['$event'],] },],
    "dragleave": [{ type: HostListener, args: ['document: dragleave', ['$event'],] },],
    "dragend": [{ type: HostListener, args: ['document: dragend', ['$event'],] },],
    "mousemove": [{ type: HostListener, args: ['document: mousemove', ['$event'],] },],
    "mouseup": [{ type: HostListener, args: ['document: mouseup', ['$event'],] },],
    "touchmove": [{ type: HostListener, args: ['document: touchmove', ['$event'],] },],
    "touchend": [{ type: HostListener, args: ['document: touchend', ['$event'],] },],
};
let offsetElement = (element) => {
    let /** @type {?} */ left = 0, /** @type {?} */ top = 0;
    while (element) {
        top += element.offsetTop - element.scrollTop + element.clientTop;
        left += element.offsetLeft - element.scrollLeft + element.clientLeft;
        element = /** @type {?} */ (element.offsetParent);
    }
    return { left: left, top: top }; // + element.scrollTop; //window.scrollY;
};
class Draggable {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.disabled = false;
        this.onDragStart = new EventEmitter();
        this.onDragEnd = new EventEmitter();
        this.isBeingDragged = false;
        this.cloneNode = null;
        this.possibleDropZones = new Map();
        this.root = el.nativeElement;
        if (!dragDropInit) {
            console.error('You should add one dragdrop attribute to your code before using draggable');
        }
        //console.log( 'new instance of Draggable', this );
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        //
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // XXX No stop in case of unplug while dragging... : // this.stop();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseDown(event) {
        //console.log('mousedown on', this, event);
        console.log(this.disabled);
        if (!this.disabled) {
            event.preventDefault();
            event.stopPropagation();
            this.prestart('mouse', event.clientX, event.clientY);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchStart(event) {
        //console.log('touchstart on', this);
        // event.preventDefault();
        event.stopPropagation();
        for (let /** @type {?} */ i = 0; i < event.changedTouches.length; i++) {
            let /** @type {?} */ touch = event.changedTouches.item(i);
            this.prestart(touch.identifier.toString(), touch.clientX, touch.clientY);
        }
    }
    /**
     * @param {?} idPointer
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    prestart(idPointer, x, y) {
        DM.preStartDrag(idPointer, this, x, y, this.startDelay || 0, this.startDistance || 10).then(() => {
            this.start(idPointer, x, y);
        }, () => {
            // console.error('skip the drag');
        });
    }
    /**
     * @param {?} idPointer
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    start(idPointer, x, y) {
        if (!this.isBeingDragged) {
            this.isBeingDragged = true;
            this.idPointer = idPointer;
            // let bbox = this.root.getBoundingClientRect();
            let /** @type {?} */ offset = offsetElement(this.root);
            this.ox = x;
            this.oy = y;
            this.dx = x - offset.left; // Math.round(bbox.left + window.pageXOffset);
            this.dy = y - offset.top; // Math.round(bbox.top  + window.pageYOffset);
            /*let D = document.querySelector('#debug');
                        D.innerHTML = window.pageXOffset + ' ; ' + window.pageYOffset + '<br/>'
                                    + window.scrollX + ' ; ' + window.scrollY + '<br/>'
                                    + this.root.offsetLeft + ' ; ' + this.root.offsetTop + '<br/>'
                                    // + bbox.left + ' ; ' + bbox.top
                                    ;*/
            this.tx = this.root.offsetWidth; // bbox.width ;
            this.ty = this.root.offsetHeight; // bbox.height;
            this.getClone();
            this.cloneNode.style.left = (x - this.dx /* + window.pageXOffset */) + 'px';
            this.cloneNode.style.top = (y - this.dy /* + window.pageYOffset */) + 'px';
            this.onDragStart.emit(this.draggedData);
            this.possibleDropZones = DM.startDrag(idPointer, this, x, y);
        }
    }
    /**
     * @return {?}
     */
    stop() {
        this.possibleDropZones.forEach(dz => {
            dz.removePointerHover(this.idPointer);
            dz.removeDropCandidatePointer(this.idPointer);
        });
        this.isBeingDragged = false;
        this.possibleDropZones.clear();
        this.idPointer = null;
        if (this.currentDropZone) {
            this.currentDropZone.drop(this.draggedData);
        }
        this.currentDropZone = null;
        this.onDragEnd.emit(this.draggedData);
        this.deleteClone();
    }
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    move(x, y) {
        let /** @type {?} */ element = null;
        if (this.cloneNode === null) {
            this.getClone();
        }
        if (this.cloneNode) {
            this.cloneNode.style.left = (x - this.dx /* + window.pageXOffset */) + 'px';
            this.cloneNode.style.top = (y - this.dy /* + window.pageYOffset */) + 'px';
            // let parent = this.cloneNode.parentElement;
            let /** @type {?} */ visibility = this.cloneNode.style.visibility;
            // parent.removeChild( this.cloneNode );
            this.cloneNode.style.visibility = 'hidden';
            let /** @type {?} */ top = this.cloneNode.style.top;
            this.cloneNode.style.top = '999999999px';
            // let L = <Array<Element>>myDoc.elementsFromPoint(x-window.pageXOffset, y-window.pageYOffset);
            element = myDoc.elementFromPoint(x, y);
            this.cloneNode.style.top = top;
            this.cloneNode.style.visibility = visibility;
            // parent.appendChild( this.cloneNode );
            let /** @type {?} */ prevDropZone = this.currentDropZone;
            while (element) {
                // Check if we are on top of a dropZone
                this.currentDropZone = this.possibleDropZones.get(element);
                if (this.currentDropZone) {
                    break;
                }
                element = /** @type {?} */ (element.parentElement);
            }
            if (prevDropZone !== this.currentDropZone) {
                if (prevDropZone) {
                    prevDropZone.removePointerHover(this.idPointer);
                }
                if (this.currentDropZone) {
                    this.currentDropZone.appendPointerHover(this.idPointer);
                }
            }
            /*this.possibleDropZones.forEach( dz => dz.removePointerHover(this.idPointer) );
                        while(element) {
                            // Check if we are on top of a dropZone
                            this.currentDropZone = this.possibleDropZones.get( element );
                            if(this.currentDropZone) {
                                this.currentDropZone.appendPointerHover( this.idPointer );
                                break;
                            }
                            element = <Element>element.parentElement;
                        }*/
        }
        return this;
    }
    /**
     * @param {?} original
     * @param {?} clone
     * @return {?}
     */
    deepStyle(original, clone) {
        if (original instanceof HTMLElement) {
            let /** @type {?} */ style = window.getComputedStyle(original);
            for (let /** @type {?} */ i = 0; i < style.length; i++) {
                let /** @type {?} */ att = style[i];
                (/** @type {?} */ (clone)).style[att] = style[att];
            }
            for (let /** @type {?} */ i = 0; i < original.children.length; i++) {
                this.deepStyle(original.children.item(i), (/** @type {?} */ (clone)).children.item(i));
            }
        }
    }
    /**
     * @return {?}
     */
    deleteClone() {
        if (this.cloneNode) {
            if (this.cloneNode.parentNode) {
                this.cloneNode.parentNode.removeChild(this.cloneNode);
            }
            this.cloneNode = null;
        }
    }
    /**
     * @return {?}
     */
    getClone() {
        if (this.cloneNode === null) {
            this.cloneNode = /** @type {?} */ (this.root.cloneNode(true));
            // Apply computed style :
            this.deepStyle(this.root, this.cloneNode);
            // Insert the clone on the DOM
            document.body.appendChild(this.cloneNode);
            this.cloneNode.style.position = 'absolute';
            this.cloneNode.style.zIndex = '999';
            this.cloneNode.style.marginLeft = '0';
            this.cloneNode.style.marginTop = '0';
            this.cloneNode.style.marginRight = '0';
            this.cloneNode.style.marginBottom = '0';
            this.cloneNode.style.opacity = '';
            this.cloneNode.style.cursor = '';
            this.cloneNode.style.transform = '';
            this.cloneNode.style.transformOrigin = '';
            this.cloneNode.style.animation = '';
            this.cloneNode.style.transition = '';
            this.cloneNode.classList.add('drag-and-drop-clone-node');
            // console.log( this.cloneNode.style );
        }
        return this.cloneNode;
    }
}
Draggable.decorators = [
    { type: Directive, args: [{
                selector: '*[draggable]'
            },] },
];
/** @nocollapse */
Draggable.ctorParameters = () => [
    { type: ElementRef, },
];
Draggable.propDecorators = {
    "draggedData": [{ type: Input, args: ['draggable',] },],
    "startDelay": [{ type: Input, args: ['drag-start-delay',] },],
    "startDistance": [{ type: Input, args: ['start-distance',] },],
    "disabled": [{ type: Input, args: ['disabled',] },],
    "onDragStart": [{ type: Output, args: ['drag-start',] },],
    "onDragEnd": [{ type: Output, args: ['drag-end',] },],
    "onMouseDown": [{ type: HostListener, args: ['mousedown', ['$event'],] },],
    "onTouchStart": [{ type: HostListener, args: ['touchstart', ['$event'],] },],
};
class Dropzone {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.nbDragEnter = 0;
        this.onDropEmitter = new EventEmitter();
        this.onDragStart = new EventEmitter();
        this.onDragEnd = new EventEmitter();
        this.onDragEnter = new EventEmitter();
        this.onDragLeave = new EventEmitter();
        this.dropCandidateofPointers = [];
        this.pointersHover = [];
        if (!dragDropInit) {
            console.error('You should add one dragdrop attribute to your code before using dropzone');
        }
        this.root = el.nativeElement;
        // this.acceptFct = YES;
        DM.registerDropZone(this);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        //
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // console.log( 'TODO: Should implement dropzone destoy');
        DM.unregisterDropZone(this);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    BrowserDragEnter(event) {
        // console.log( 'BrowserDragEnter', this, event );
        this.nbDragEnter++;
        if (this.nbDragEnter === 1) {
            this.appendPointerHover(dragPointerId);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    BrowserDragLeave(event) {
        // console.log( 'BrowserDragEnter', this, event );
        this.nbDragEnter--;
        if (this.nbDragEnter === 0) {
            this.removePointerHover(dragPointerId);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    BrowserDrop(event) {
        // console.log( 'BrowserDrop', this, event );
        DM.pointerRelease(dragPointerId);
        this.nbDragEnter = 0;
        this.onDropEmitter.emit(event);
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    drop(obj) {
        // console.log( this, 'drop', obj );
        this.onDropEmitter.emit(obj);
    }
    /**
     * @param {?} drag
     * @return {?}
     */
    checkAccept(drag) {
        let /** @type {?} */ res;
        if (drag instanceof Draggable) {
            res = this.acceptFunction ? this.acceptFunction(drag.draggedData) : true;
        }
        else {
            res = this.acceptFunction ? this.acceptFunction(drag) : true;
        }
        return res;
    }
    /**
     * @param {?} idPointer
     * @return {?}
     */
    hasPointerHover(idPointer) {
        return this.pointersHover.indexOf(idPointer) >= 0;
    }
    /**
     * @param {?} idPointer
     * @return {?}
     */
    appendPointerHover(idPointer) {
        if (this.pointersHover.indexOf(idPointer) === -1) {
            let /** @type {?} */ dragged = DM.draggedStructures.get(idPointer);
            this.pointersHover.push(idPointer);
            if (dragged instanceof Draggable) {
                if (this.dragOverCSS_pointer) {
                    dragged.getClone().classList.add(this.dragOverCSS_pointer);
                }
                this.onDragEnter.emit(dragged.draggedData);
            }
            else {
                this.onDragEnter.emit(dragged);
            }
            if (this.dragOverCSS) {
                this.root.classList.add(this.dragOverCSS);
            }
        }
    }
    /**
     * @param {?} idPointer
     * @return {?}
     */
    removePointerHover(idPointer) {
        let /** @type {?} */ pos = this.pointersHover.indexOf(idPointer);
        if (pos >= 0) {
            let /** @type {?} */ dragged = DM.draggedStructures.get(idPointer);
            this.pointersHover.splice(pos, 1);
            if (dragged instanceof Draggable) {
                if (this.dragOverCSS_pointer) {
                    dragged.getClone().classList.remove(this.dragOverCSS_pointer);
                }
                this.onDragLeave.emit(dragged.draggedData);
            }
            else {
                this.onDragLeave.emit(dragged);
            }
            if (this.pointersHover.length === 0 && this.dragOverCSS) {
                this.root.classList.remove(this.dragOverCSS);
            }
        }
    }
    /**
     * @param {?} idPointer
     * @return {?}
     */
    appendDropCandidatePointer(idPointer) {
        // console.log( 'appendDropCandidatePointer', idPointer, this );
        if (this.dropCandidateofPointers.indexOf(idPointer) === -1) {
            let /** @type {?} */ dragged = DM.draggedStructures.get(idPointer);
            if (dragged instanceof Draggable) {
                this.onDragStart.emit(dragged.draggedData);
            }
            else {
                this.onDragStart.emit(dragged);
            }
            this.dropCandidateofPointers.push(idPointer);
            if (this.dragCSS) {
                this.root.classList.add(this.dragCSS);
            }
        }
    }
    /**
     * @param {?} idPointer
     * @return {?}
     */
    removeDropCandidatePointer(idPointer) {
        let /** @type {?} */ pos = this.dropCandidateofPointers.indexOf(idPointer);
        if (pos >= 0) {
            let /** @type {?} */ dragged = DM.draggedStructures.get(idPointer);
            if (dragged instanceof Draggable) {
                this.onDragEnd.emit(dragged.draggedData);
            }
            else {
                this.onDragEnd.emit(dragged);
            }
            this.dropCandidateofPointers.splice(pos, 1);
            if (this.dropCandidateofPointers.length === 0 && this.dragCSS) {
                this.root.classList.remove(this.dragCSS);
            }
        }
    }
}
Dropzone.decorators = [
    { type: Directive, args: [{ selector: '*[dropzone]' },] },
];
/** @nocollapse */
Dropzone.ctorParameters = () => [
    { type: ElementRef, },
];
Dropzone.propDecorators = {
    "dragCSS": [{ type: Input, args: ['drag-css',] },],
    "dragOverCSS": [{ type: Input, args: ['drag-over-css',] },],
    "dragOverCSS_pointer": [{ type: Input, args: ['drag-over-css-for-draggable',] },],
    "acceptFunction": [{ type: Input, args: ['accept-function',] },],
    "onDropEmitter": [{ type: Output, args: ['ondrop',] },],
    "onDragStart": [{ type: Output, args: ['drag-start',] },],
    "onDragEnd": [{ type: Output, args: ['drag-end',] },],
    "onDragEnter": [{ type: Output, args: ['drag-enter',] },],
    "onDragLeave": [{ type: Output, args: ['drag-leave',] },],
    "BrowserDragEnter": [{ type: HostListener, args: ['dragenter', ['$event'],] },],
    "BrowserDragLeave": [{ type: HostListener, args: ['dragleave', ['$event'],] },],
    "BrowserDrop": [{ type: HostListener, args: ['drop', ['$event'],] },],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class NgxDragAndDropModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NgxDragAndDropModule,
            providers: []
        };
    }
}
NgxDragAndDropModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                ],
                declarations: [
                    Draggable,
                    Dropzone,
                    DragDrop,
                ],
                exports: [
                    Draggable,
                    Dropzone,
                    DragDrop,
                ]
            },] },
];
/** @nocollapse */
NgxDragAndDropModule.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { NgxDragAndDropModule, DragDrop as ɵa, Draggable as ɵb, Dropzone as ɵc };
//# sourceMappingURL=ngx-drag-and-drop.js.map
